using Grpc.Core;
using KubeMind.Proto;
using Microsoft.SemanticKernel;
using System.Text.Json;
using KubeMind.Brain.Application.Plugins;
using KubeMind.Brain.Application.Services; // Add this
using Microsoft.SemanticKernel.Planning.Handlebars;
using static KubeMind.Proto.IncidentService;

namespace KubeMind.Brain.Api.Services;

/// <summary>
/// Implements the gRPC service for receiving incident data from Observers.
/// </summary>
public class IncidentService : IncidentServiceBase
{
    private readonly ILogger<IncidentService> _logger;
    private readonly Kernel _kernel;
    private readonly IEnrichmentService _enrichmentService;

    public IncidentService(ILogger<IncidentService> logger, Kernel kernel, IEnrichmentService enrichmentService)
    {
        _logger = logger;
        _kernel = kernel;
        _enrichmentService = enrichmentService;
    }

    /// <summary>
    /// Handles a client-side stream of IncidentContext messages.
    /// </summary>
    public override async Task<StreamIncidentResponse> StreamIncident(
        IAsyncStreamReader<IncidentContext> requestStream,
        ServerCallContext context)
    {
        _logger.LogInformation("Client stream started.");

        var planner = new HandlebarsPlanner(new HandlebarsPlannerOptions() { AllowLoops = true });

        await foreach (var incident in requestStream.ReadAllAsync(context.CancellationToken))
        {
            _logger.LogInformation(
                "Received Incident '{IncidentId}' for Pod '{PodName}' in namespace '{Namespace}'. Reason: {Reason}",
                incident.IncidentId,
                incident.PodName,
                incident.PodNamespace,
                incident.FailureReason);

            var incidentJson = JsonSerializer.Serialize(incident);
            
            var originalGoal = $$$"""
            Analyze the following Kubernetes incident and get the pod's current status.
            Then, provide a structured JSON diagnosis using the K8sDiagnosticsPlugin.AnalyzeIncident function.
            Based on the diagnosis, propose a fix, and if a fix is identified, create a pull request using the GitOpsPlugin.CreateFixPullRequest function.
            For the pull request, use:
            - repositoryOwner: "your-github-username"
            - repositoryName: "your-test-repo"
            - baseBranch: "main"
            - newBranchName: "fix/incident-{{incident.IncidentId}}"
            - commitMessage: "Fix: {{diagnosis.RootCause}}"
            - filePath: "deployment.yaml"
            - fileContent: "Simulated updated deployment content based on {{diagnosis.RecommendedAction}}"
            - pullRequestTitle: "Automated Fix for Incident {{incident.IncidentId}}: {{diagnosis.RootCause}}"
            - pullRequestBody: "This PR was automatically generated by KubeMind Brain to address the incident. Diagnosis: {{diagnosis.RootCause}}. Recommended Action: {{diagnosis.RecommendedAction}}"

            Incident:
            {{{incidentJson}}}
            """;

            var enrichedGoal = await _enrichmentService.EnrichGoalWithCognitiveMemoryAsync(incident, originalGoal, context.CancellationToken);

            var plan = await planner.CreatePlanAsync(_kernel, enrichedGoal);
            _logger.LogInformation("Plan created: {Plan}", plan);
            
            var result = await plan.InvokeAsync(_kernel);

            _logger.LogInformation("Diagnosis for Incident {IncidentId}: {Diagnosis}", incident.IncidentId, result);
        }

        _logger.LogInformation("Client stream finished.");

        return new StreamIncidentResponse
        {
            Status = "Incidents received and processed."
        };
    }
}
